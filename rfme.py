# -*- coding: utf-8 -*-
"""rfme.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MX1xonpnegc-6os6BH3WwSXcS0hVWf11
"""

import sys
import subprocess
import pkg_resources

required = {'pandas', 'numpy', 'plotly', 'scikit-learn'}
installed = {pkg.key for pkg in pkg_resources.working_set}
missing = required - installed

if missing:
    python = sys.executable
    subprocess.check_call([python, '-m', 'pip', 'install', *missing], stdout=subprocess.DEVNULL)

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans

import plotly.graph_objects as go

pd.options.mode.chained_assignment = None

colors = dict({'recency':'honeydew',
              'frequency':'indianred',
              'monetary_value':'forestgreen',
               'engagement':'limegreen'})
cluster_dict = dict({
              "0" : 'Ideal',
              "1" : 'High-Value',
              "2" : 'Potential',
              "3" : 'Lost'})
cluster_color = dict({
              "0" : 'forestgreen',
              "1" : 'limegreen',
              "2" : 'indianred',
              "3" : 'honeydew'})

#Data upload: \\
# Backend-http://app.redash.licagroup.ph/queries/112 \\
# Engagement-https://docs.google.com/spreadsheets/d/1JDdrHrFVvLnjMabaCjj9XYSU5sdrz9-S7pbJWW643pY/edit#gid=1198365844 \\
# Garage data-http://app.redash.licagroup.ph/queries/99


#Backend data
df_backend = pd.read_csv("http://app.redash.licagroup.ph/api/queries/112/results.csv?api_key=Tz8lLRHbcyOTGfHprtKqICB8txfFm4mNuNbFWlZF", parse_dates = ['created_at'])
df_backend = df_backend[['created_at','id', 'product_desc','GarageId','Income','total_price_no_shipping','garage_type']]
df_backend.columns = ['date', 'id', 'product_desc', 'garage_id', 'income', 'revenue', 'garage_type']
df_backend['date'] = df_backend['date'].dt.date
df_backend['garage_type'].loc[df_backend['garage_type']== 'Inactive'] = 'B2C'
df_backend['garage_type'].loc[df_backend['garage_type']== 'nonlica_delearship'] = 'nonlica_dealership'

#Engagement data
sheet_id = '1JDdrHrFVvLnjMabaCjj9XYSU5sdrz9-S7pbJWW643pY'
sheet_name = 'goparts_analysis_website'
url = f"https://docs.google.com/spreadsheets/d/{sheet_id}/gviz/tq?tqx=out:csv&sheet={sheet_name}"
e_data = pd.read_csv(url)
e_data = e_data.fillna(0)
e_data.columns = ['garage_id','avg_session_duration', 'pageviews_per_session', 'sessions', 'adds_to_cart', 'checkouts']
e_data['garage_id'] =e_data['garage_id'].astype(int)
e_data['engagement'] = e_data['avg_session_duration']/e_data['avg_session_duration'].max() + e_data['pageviews_per_session']/e_data['pageviews_per_session'].max() +e_data['sessions']/e_data['sessions'].max() + e_data['adds_to_cart']/e_data['adds_to_cart'].max() + e_data['checkouts']/e_data['checkouts'].max()

#Data for garages
df_garage = pd.read_csv("http://app.redash.licagroup.ph/api/queries/99/results.csv?api_key=K0xX1pdowwI5Wepot0SUkZqhtnRqpr9bUcqBdiRB")
df_garage = df_garage[['id','shop_name', 'address']]
df_garage.columns = ['garage_id', 'shop','location']

def grade(rank):
    if rank >0.80:
        return 5
    elif rank > 0.60:
        return 4
    elif rank > 0.40:
        return 3
    elif rank > 0.20:
        return 2
    else:
        return 1
        
def r_grade(recency):  
    if recency < 2*30:
      return 5
    elif recency <3*30:
      return 4
    elif recency < 4*30:
      return 3
    elif recency < 5*30:
      return 2
    else:
      return 1

def f_grade(frequency):  
    if frequency < 10:
      return 1
    elif frequency <20:
      return 2
    elif frequency < 30:
      return 3
    elif frequency < 40:
      return 4
    else:
      return 5

def get_rfm(df_input, engagement = False, garage_type = 'all', monetary_column = 'income'): #garage_type= all, non-rapide, rapide, non-B2C
  df_out = pd.DataFrame()
  df_input = df_input.loc[df_input[monetary_column].fillna(0).astype(float) > 0]
  if garage_type =='Non-Rapide':
    df_input = df_input.loc[df_input['garage_type'] != 'rapide_service_center' ]
  elif garage_type == 'Rapide':
    df_input = df_input.loc[df_input['garage_type'] == 'rapide_service_center' ]
  elif garage_type == 'Non-B2C':
    df_input = df_input.loc[~df_input['garage_type'].isin(['rapide_service_center','B2C'])]
  df_out[['recency','frequency', 'monetary_value']] = df_input.groupby('garage_id').agg(
                                                                                        recency = ('date', lambda x: (pd.Timestamp.today().date() - x).min().days -1),
                                                                                        frequency = ('id', lambda x: x.nunique()),
                                                                                        monetary_value = (monetary_column, lambda x: x.sum())                                                                                        
                                                                                    )
  if engagement:
    df_out = df_out.reset_index().merge(e_data[['garage_id','engagement']], on='garage_id',how= 'left').set_index('garage_id').fillna(0)
  return df_out

def score_rfm(df_input, classic = True):
  if classic:
    df_input[['R','F','M']] = df_input[['recency','frequency','monetary_value']].apply(lambda x: x.rank(pct=True).apply(grade),axis=0)
    df_input['R'] = df_input['R'].apply(lambda x:6-x)
  elif ~classic:
    df_input['R'] = df_input['recency'].apply(r_grade)
    df_input['F'] = df_input['frequency'].apply(f_grade)
    df_input['M'] = df_input['monetary_value'].rank(pct=True).apply(grade)
  if 'engagement'in df_input.columns:
    df_input['E'] = df_input['engagement'].rank(pct=True).apply(grade)
  df_input['score'] = df_input['R'].astype(str)+df_input['F'].astype(str)+df_input['M'].astype(str)
  if 'engagement'in df_input.columns:
    df_input['score'] = df_input['score']+df_input['E'].astype(str)
  return df_input

def get_clusters(df_input):
  if 'engagement'in df_input.columns:
    df_temp = df_input[['R','F', 'M', 'E']]
    cluster_centers = np.array([[5,5,5,5],[4,1,3,1],[3,1,1,3],[1,1,1,1]])
  else:
    df_temp = df_input[['R','F', 'M']]
    cluster_centers = np.array([[5,5,5],[3,1,1],[1,3,3],[1,1,1]])
  nclusters = len(cluster_centers)
  model = KMeans(n_clusters = nclusters, init= cluster_centers, max_iter = 5000)
  cluster_labels = model.fit_predict(df_temp)
  df_input['cluster'] = cluster_labels
  return df_input

def insert_info(df_input, df_info, id):
  return df_input.merge(df_info, left_index=True,right_on=id,how ='inner').drop_duplicates(keep='first').set_index(id)

def initList(size):
    list_of_objects = list()
    for i in range(0,size):
        list_of_objects.append( [False]*size ) #different object reference each time
    return list_of_objects

def violin_plots(df_temp, engagement = False):
  fig = go.Figure()

  cols = 3
  if engagement:
    cols = cols+1

  for col in df_temp.columns[:cols]:
      fig.add_trace(
          go.Violin(
                      y=df_temp[col], box_visible = True, line_color = 'black',
                      meanline_visible=True, fillcolor=colors[col], opacity=0.6,
                      x0=col, hovertemplate = "%{y}", points='all', name =col.title()
                      )
      )

  buttons = [dict(label = 'All',
                  method = 'update',
                  args = [{'visible': [True]*cols},
                          {'title': "Violin plots for Garage's Distributions"},
                          {'showlegend':True}])]

  visible_plot = initList(cols)
  for i in range(cols):
    visible_plot[i][i] = True

  for col in df_temp.columns[:cols]:
    buttons.append(
        dict(
            label = col.title(),
            method = 'update',
            args = [{'visible': visible_plot[list(df_temp.columns).index(col)]},
                    {'title': "Violin plot for Garage's Distribution for "+col},
                    {'showlegend':True}]
        )
    )


  fig.update_layout(template = 'simple_white', title = "Violin plots for Garage's Distributions for Recency, Frequency, and Monetary Value",
      updatemenus=[go.layout.Updatemenu(
          active=0,
          buttons=buttons,
          showactive = True,
          type ='buttons',
          y = 1.15,
          x = 1,
          direction = 'right')
      ])


  fig.update_xaxes(showline=True, linewidth=1, linecolor='black', mirror=True)
  fig.update_yaxes(showline=True, linewidth=1, linecolor='black', mirror=True)

  st.plotly_chart(fig)

def grpbar_plots(df_temp_):
  fig = go.Figure()
  c = len(df_temp_.columns[::2])
  #df_temp_ = df_temp.reset_index()
  for col in df_temp_.columns[::2]:
      fig.add_trace(
          go.Bar(
                  name = col,
                  legendgroup = col,
                  x =df_temp_.index,  
                  y=df_temp_[col].round(2),
                  opacity=0.6,
                  x0=col, hovertemplate = "%{y},%{x}",
                  error_y =dict(
                      type='data',
                      array = df_temp_[df_temp_.columns[list(df_temp_.columns).index(col)+1]]/2
                  ),
                 text=df_temp_[col].round(2),
                 textposition ='outside'
                )
      )
  buttons = [dict(label = 'All',
                  method = 'update',
                  args = [{'visible': [True]*c},
                          {'title': "Bar Chart for Parameter Values per Cluster"},
                          {'showlegend':True}])]
  visible_plot = initList(c)
  for i in range(c):
    visible_plot[i][i] = True

  for col in range(len(df_temp_.columns[::2])):
    print(visible_plot[col],col)
    buttons.append(
        dict(
            label = df_temp_.columns[::2][col],
            method = 'update',
            args = [{'visible': visible_plot[col]},
                    {'title': "Bar Chart for "+df_temp_.columns[::2][col]+" per Cluster"},
                    {'showlegend':True}]
        )
    )

  fig.update_layout(
      updatemenus=[go.layout.Updatemenu(
          active=0,
          buttons=buttons,
          showactive = True,
          type ='buttons',
          y = 1.15,
          x = 1,
          direction = 'right')
      ])

  fig.update_layout(template = 'simple_white',legend=dict(
                            yanchor="bottom",
                            y=-0.3,
                            xanchor="left",
                            x=0.01,
                            orientation = 'h'
                        ))#, title = "Bar Cart for "+col.title()+" (number of says since last order) per Cluster")
  fig.update_xaxes(showline=True, linewidth=1, linecolor='black', mirror=True)
  fig.update_yaxes(showline=True, linewidth=1, linecolor='black', mirror=True, rangemode='tozero')

  st.plotly_chart(fig)

def find_cluster(df_temp,engagement):
  df_cluster = pd.DataFrame()
  df_cluster[['mean_recency','recency_std','mean_frequency','frequency_std', 'mean_monetary_value','monetary_value_std']] = df_temp.groupby('cluster').agg(
                                                                                    recency_mean = ('recency', lambda x: x.mean()),
                                                                                    recency_std = ('recency', lambda x: x.std()),
                                                                                    frequency_mean = ('frequency', lambda x: x.mean()),
                                                                                    frequency_std = ('frequency', lambda x: x.std()),
                                                                                    monetary_value_mean = ('monetary_value', lambda x: x.mean()),
                                                                                    monetary_value_std = ('monetary_value', lambda x: x.std())
                                                                                )
  if engagement:
    df_cluster[['mean_engagement','engagement_std']]= df_temp.groupby('cluster').agg(
        engagement_mean = ('engagement', lambda x: x.mean()),
        engagement_std = ('engagement', lambda x: x.std())
    )
  df_cluster = df_cluster.reset_index()
  df_cluster['cluster'] = df_cluster['cluster'].apply(lambda x: cluster_dict[str(x)])
  df_cluster = df_cluster.set_index('cluster')
  return df_cluster

def stacked_bar_cluster(df_temp):
  df_data = df_temp.groupby(['cluster','garage_type'])['shop'].count().unstack().reset_index().set_index('cluster').fillna(0)
  fig = go.Figure()

  for col in df_data.columns:
        fig.add_trace(
            go.Bar(
                    name = col,
                    x =df_data.index,  
                    y=df_data[col],
                    opacity=0.6,
                    x0=col)
        )
  fig.update_layout(barmode='stack',template = 'simple_white', title = "Composition of Each Cluster Based on Garage Type")
  fig.update_xaxes(showline=True, linewidth=1, linecolor='black', mirror=True)
  fig.update_yaxes(showline=True, linewidth=1, linecolor='black', mirror=True)
  st.plotly_chart(fig)

st.sidebar.header('Parameters for Analysis')
st.sidebar.text('Select the parameters that would\nbe taken into account during the\nanalysis.')
garage_type = st.sidebar.selectbox(
    label = 'Select considered garages:',
    options =(' ','All','Rapide', 'Non-Rapide', 'Non-B2C'))
engagement = st.sidebar.checkbox(label ="With engagement data.")
modified = st.sidebar.checkbox(label ="Modified scoring")
date_start = st.sidebar.date_input(
     label = "Select start of considered dates",
     value = df_backend['date'].min(),
     min_value=df_backend['date'].min(),
     max_value=df_backend['date'].max())
date_end = st.sidebar.date_input(
     label = "Select end of considered dates",
     value = df_backend['date'].max(),
     min_value=df_backend['date'].min(),
     max_value=df_backend['date'].max())
monetary_value_col= st.sidebar.radio(
     "Select monetary value basis:",
     ('Income', 'Revenue'))

if engagement:
    rfm = "RFME"
else:
    rfm = "RFM"
    
if garage_type== ' 'or (date_start>date_end):  
    st.title(rfm+" analysis for GoParts Garages")
    
    st.markdown("This app classifies the garages of GoParts based on "+rfm+" classification.Relevant data are also presented such as the distribution of classification parameters per cluster. Kindly select the _parameters_ in the sidebar to begin analysis.")    
    if (date_start>date_end):
        st.write("Please indicate a valid date interval.")

elif garage_type!= ' ' and (date_start<date_end):
    st.title(rfm+" analysis for GoParts Garages")
    df_input=df_backend.loc[df_backend['date']>date_start].loc[df_backend['date']<date_end]
    df_rfm=get_rfm(df_input, engagement,garage_type,monetary_value_col.lower())
    violin_plots(df_rfm,engagement)
    df_rfm =get_clusters(score_rfm(df_rfm,~modified))
    if engagement:
        df_rfm = df_rfm[['cluster','score','recency','frequency','monetary_value','engagement']]
    else:
        df_rfm = df_rfm[['cluster','score','recency','frequency','monetary_value']]

    df_rfm = insert_info(df_rfm, df_backend.reset_index()[['garage_id','garage_type']], 'garage_id')
    df_rfm = insert_info(df_rfm, df_garage, 'garage_id')
    
    df_cluster = find_cluster(df_rfm, engagement)
    df_rfm = df_rfm.set_index('shop').sort_values(by='score',ascending=False)
    df_rfm['cluster'] = df_rfm['cluster'].apply(lambda x: cluster_dict[str(x)])
    df_rfm_ = df_rfm.copy()
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["All","Ideal", "High-Value", "Potential", "Lost"])
    if len(df_rfm_['garage_type'].unique())==1:
        df_rfm_ = df_rfm_.drop('garage_type',axis=1)
    with tab1:
        st.header("Data for all clusters in "+garage_type+" garages:")
        df_all = df_rfm_ 
        st.write(df_all)
    with tab2:
        cluster_filter = "Ideal"
        st.header("Data for "+ cluster_filter+" in "+garage_type+" garages:")
        df_temp_ =df_rfm_.loc[df_rfm_['cluster']==cluster_filter]
        df_temp_ = df_temp_.drop('cluster',axis=1)
        st.write(df_temp_)
    with tab3:
        cluster_filter = "High-Value"
        st.header("Data for "+ cluster_filter+" in "+garage_type+" garages:")
        df_temp_ =df_rfm_.loc[df_rfm_['cluster']==cluster_filter]
        df_temp_ = df_temp_.drop('cluster',axis=1)
        st.write(df_temp_)
    with tab4:
        cluster_filter = "Potential"
        st.header("Data for "+ cluster_filter+" in "+garage_type+" garages:")
        df_temp_=df_rfm_.loc[df_rfm_['cluster']==cluster_filter]
        df_temp_ = df_temp_.drop('cluster',axis=1)
        st.write(df_temp_)
    with tab5:
        cluster_filter = "Lost"
        st.header("Data for "+ cluster_filter+" in "+garage_type+" garages:")
        df_temp_=df_rfm_.loc[df_rfm_['cluster']==cluster_filter]
        df_temp_ = df_temp_.drop('cluster',axis=1)
        st.write(df_temp_)
    
    grpbar_plots(df_cluster)
    if engagement:
        df_cluster = df_cluster[['mean_recency','mean_frequency','mean_monetary_value','mean_engagement']]
    else:
        df_cluster = df_cluster[['mean_recency','mean_frequency','mean_monetary_value']]
    st.write(df_cluster)
    stacked_bar_cluster(df_rfm.reset_index())